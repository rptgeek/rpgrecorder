---
phase: 02-core-value---ai-summarization-&-search
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/app/api/transcribe-webhook/route.ts, src/lib/search/fts.ts, src/app/api/search/route.ts]
autonomous: true
must_haves:
  truths:
    - "User can search for specific keywords across sessions"
    - "New transcripts are automatically indexed for search"
  artifacts:
    - path: "src/lib/search/fts.ts"
      provides: "Postgres FTS query logic"
    - path: "src/app/api/search/route.ts"
      provides: "Search API endpoint"
  key_links:
    - from: "src/app/api/transcribe-webhook/route.ts"
      to: "Session.transcriptText"
      via: "JSON flattening logic"
---

<objective>
Implement PostgreSQL Full-Text Search (FTS) and ensure session transcripts are stored in a searchable text format.

Purpose: Enables keyword search (SEARCH-01) and provides a clean text source for AI summarization.
Output: FTS index in DB, search API, and automatic text flattening during transcription.
</objective>

<execution_context>
@./.gemini/get-shit-done/workflows/execute-plan.md
@./.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-value---ai-summarization-&-search/02-01-SUMMARY.md
@src/app/api/transcribe-webhook/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Postgres FTS Indexing</name>
  <files>prisma/migrations/fts_setup.sql</files>
  <action>
    Create a manual SQL migration or use `prisma.$executeRaw` in a script to:
    1. Add a `search_vector` column of type `tsvector` to the `Session` table.
    2. Create a GIN index on `search_vector`.
    3. Create a trigger function that updates `search_vector` by concatenating `name`, `description`, and `transcriptText`.
    4. Attach the trigger to the `Session` table.
    
    Reference research recommendation: Use `to_tsvector('english', ...)` for indexing.
  </action>
  <verify>Run a raw SQL query like `SELECT search_vector FROM "Session" LIMIT 1` to ensure the column exists and has content.</verify>
  <done>Postgres FTS vector and index are active on the Session table.</done>
</task>

<task type="auto">
  <name>Task 2: Flatten Transcripts & Search API</name>
  <files>src/app/api/transcribe-webhook/route.ts, src/lib/search/fts.ts, src/app/api/search/route.ts</files>
  <action>
    1. Update `src/app/api/transcribe-webhook/route.ts`: After parsing `transcriptJson`, extract all "transcript" values from the items array into a single `transcriptText` string. Update the `Session` record with both `transcriptJson` and `transcriptText`.
    2. Create `src/lib/search/fts.ts`: Implement `searchSessions(query: string)` using `prisma.$queryRaw` with the `@@` operator and `websearch_to_tsquery`.
    3. Create `src/app/api/search/route.ts`: A GET endpoint that accepts a `q` param and returns ranked session results using `searchSessions`.
  </action>
  <verify>
    1. Manually trigger or mock a webhook call and verify `transcriptText` is populated in DB.
    2. Call `/api/search?q=test` and verify it returns a valid JSON response.
  </verify>
  <done>Transcripts are saved as flat text and searchable via the API.</done>
</task>

</tasks>

<verification>
- Raw SQL query confirms `search_vector` exists.
- `/api/search` returns results based on transcript content.
</verification>

<success_criteria>
- Keywords in session names or transcripts are findable via API.
- Transcription webhook populates the `transcriptText` field.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-value---ai-summarization-&-search/02-02-SUMMARY.md`
</output>
