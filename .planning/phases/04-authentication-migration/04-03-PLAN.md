---
phase: 04-authentication-migration
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/auth.ts
  - src/lib/cognito/jwt-utils.ts
  - src/types/next-auth.d.ts
  - src/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Auth.js uses Cognito provider instead of CredentialsProvider"
    - "JWT tokens from Cognito are stored and refreshed automatically"
    - "User sessions persist across browser restarts via refresh tokens"
    - "Cognito 'sub' claim is available as user ID for DynamoDB partition key"
    - "Middleware protects routes using Cognito JWT validation"
  artifacts:
    - path: "src/auth.ts"
      provides: "Auth.js configuration with Cognito provider"
      contains: "CognitoProvider"
      min_lines: 40
    - path: "src/lib/cognito/jwt-utils.ts"
      provides: "JWT verification and refresh utilities"
      exports: ["verifyAccessToken", "refreshAccessToken"]
    - path: "src/types/next-auth.d.ts"
      provides: "TypeScript types for Cognito JWT fields"
      contains: "accessToken"
  key_links:
    - from: "src/auth.ts"
      to: "Cognito User Pool"
      via: "CognitoProvider configuration"
      pattern: "COGNITO_ISSUER"
    - from: "src/auth.ts"
      to: "src/lib/cognito/jwt-utils.ts"
      via: "token refresh callback"
      pattern: "refreshAccessToken"
    - from: "src/middleware.ts"
      to: "src/auth.ts"
      via: "withAuth"
      pattern: "withAuth"
---

<objective>
Integrate Auth.js with Cognito OAuth provider, replacing CredentialsProvider with Cognito-based JWT authentication.

Purpose: Complete the authentication migration so users authenticate via Cognito (AUTH-03) with JWT token management (AUTH-05).
Output: Updated auth configuration, JWT utilities, TypeScript types, and middleware.
</objective>

<execution_context>
@C:\Users\gpope1\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpope1\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-authentication-migration/04-RESEARCH.md
@.planning/phases/04-authentication-migration/04-01-SUMMARY.md
@.planning/phases/04-authentication-migration/04-02-SUMMARY.md
@src/auth.ts
@src/middleware.ts
@src/types/next-auth.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT Utilities and Install Dependencies</name>
  <files>src/lib/cognito/jwt-utils.ts, package.json</files>
  <action>
Install Cognito SDK and JWT verification packages, then create JWT utility functions.

1. Install dependencies:
```bash
npm install aws-jwt-verify @aws-sdk/client-cognito-identity-provider
```

2. Create `src/lib/cognito/jwt-utils.ts`:
```typescript
import { CognitoJwtVerifier } from "aws-jwt-verify";
import { CognitoIdentityProviderClient, InitiateAuthCommand } from "@aws-sdk/client-cognito-identity-provider";

// JWT Verifier (singleton, caches JWKS)
const verifier = CognitoJwtVerifier.create({
  userPoolId: process.env.COGNITO_USER_POOL_ID!,
  clientId: process.env.COGNITO_CLIENT_ID!,
  tokenUse: "access",
});

// Cognito client for token refresh
const cognitoClient = new CognitoIdentityProviderClient({
  region: process.env.AWS_REGION || "us-east-1",
});

export interface VerifyResult {
  valid: boolean;
  payload?: {
    sub: string;
    email?: string;
    "cognito:username"?: string;
    exp: number;
    iat: number;
  };
  error?: string;
}

/**
 * Verify a Cognito access token server-side.
 * Used for API route protection and middleware.
 */
export async function verifyAccessToken(token: string): Promise<VerifyResult> {
  try {
    const payload = await verifier.verify(token);
    return {
      valid: true,
      payload: {
        sub: payload.sub,
        email: payload.email as string | undefined,
        "cognito:username": payload["cognito:username"] as string | undefined,
        exp: payload.exp,
        iat: payload.iat,
      },
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : "Token verification failed",
    };
  }
}

export interface RefreshResult {
  success: boolean;
  accessToken?: string;
  idToken?: string;
  expiresIn?: number;
  error?: string;
}

/**
 * Refresh expired access token using refresh token.
 * Called from Auth.js jwt callback when token expires.
 */
export async function refreshAccessToken(refreshToken: string): Promise<RefreshResult> {
  try {
    const command = new InitiateAuthCommand({
      ClientId: process.env.COGNITO_CLIENT_ID!,
      AuthFlow: "REFRESH_TOKEN_AUTH",
      AuthParameters: {
        REFRESH_TOKEN: refreshToken,
      },
    });

    const response = await cognitoClient.send(command);

    if (!response.AuthenticationResult) {
      return { success: false, error: "No authentication result" };
    }

    return {
      success: true,
      accessToken: response.AuthenticationResult.AccessToken,
      idToken: response.AuthenticationResult.IdToken,
      expiresIn: response.AuthenticationResult.ExpiresIn,
    };
  } catch (error) {
    console.error("Token refresh failed:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Refresh failed",
    };
  }
}

/**
 * Check if token is about to expire (within buffer seconds).
 * Default buffer is 60 seconds to account for network latency.
 */
export function isTokenExpiring(expiresAt: number, bufferSeconds: number = 60): boolean {
  const now = Math.floor(Date.now() / 1000);
  return now >= expiresAt - bufferSeconds;
}
```
  </action>
  <verify>
- Package installed: `npm ls aws-jwt-verify @aws-sdk/client-cognito-identity-provider`
- File exists: `ls src/lib/cognito/jwt-utils.ts`
- TypeScript compiles: `npx tsc --noEmit src/lib/cognito/jwt-utils.ts`
  </verify>
  <done>
JWT utilities created with token verification and refresh functions. Dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Auth.js Configuration with Cognito Provider</name>
  <files>src/auth.ts, src/types/next-auth.d.ts, src/middleware.ts</files>
  <action>
Replace CredentialsProvider with Cognito OAuth provider and update session/JWT callbacks.

1. Update `src/auth.ts`:
```typescript
import NextAuth from "next-auth";
import type { NextAuthOptions } from "next-auth";
import CognitoProvider from "next-auth/providers/cognito";
import { refreshAccessToken, isTokenExpiring } from "@/lib/cognito/jwt-utils";

export const authConfig: NextAuthOptions = {
  providers: [
    CognitoProvider({
      clientId: process.env.COGNITO_CLIENT_ID!,
      clientSecret: process.env.COGNITO_CLIENT_SECRET!,
      issuer: process.env.COGNITO_ISSUER!,
      // Don't link accounts by email (security)
      allowDangerousEmailAccountLinking: false,
    }),
  ],
  session: {
    strategy: "jwt" as const,
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    async jwt({ token, user, account }) {
      // Initial sign-in: store Cognito tokens
      if (account && user) {
        return {
          ...token,
          accessToken: account.access_token,
          refreshToken: account.refresh_token,
          idToken: account.id_token,
          expiresAt: Math.floor(Date.now() / 1000) + (account.expires_in || 3600),
          // Use Cognito 'sub' as user ID (stable partition key for DynamoDB)
          id: account.providerAccountId, // This is the Cognito 'sub'
        };
      }

      // Check if token needs refresh (60 second buffer)
      if (token.expiresAt && isTokenExpiring(token.expiresAt as number)) {
        console.log("Access token expiring, attempting refresh...");

        const refreshed = await refreshAccessToken(token.refreshToken as string);

        if (refreshed.success) {
          return {
            ...token,
            accessToken: refreshed.accessToken,
            idToken: refreshed.idToken,
            expiresAt: Math.floor(Date.now() / 1000) + (refreshed.expiresIn || 3600),
          };
        } else {
          console.error("Token refresh failed:", refreshed.error);
          // Return token with error flag - session callback can handle
          return { ...token, error: "RefreshTokenError" };
        }
      }

      return token;
    },
    async session({ session, token }) {
      // Pass Cognito 'sub' as user ID for database queries
      session.user.id = token.id as string;

      // Expose access token for API calls (if needed)
      (session as any).accessToken = token.accessToken;

      // Expose refresh error if present
      if (token.error) {
        (session as any).error = token.error;
      }

      return session;
    },
  },
  pages: {
    signIn: "/login", // Custom login page
    error: "/login", // Redirect errors to login
  },
  secret: process.env.NEXTAUTH_SECRET,
};

export default NextAuth(authConfig);
```

2. Update `src/types/next-auth.d.ts`:
```typescript
import NextAuth, { DefaultSession } from "next-auth";
import { JWT } from "next-auth/jwt";

declare module "next-auth" {
  interface Session {
    user: {
      /** Cognito 'sub' claim - stable ID for DynamoDB partition key */
      id: string;
    } & DefaultSession["user"];
    /** Cognito access token for API calls */
    accessToken?: string;
    /** Error flag if token refresh failed */
    error?: string;
  }

  interface User {
    id: string;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    /** Cognito 'sub' claim */
    id: string;
    /** Cognito access token */
    accessToken?: string;
    /** Cognito refresh token */
    refreshToken?: string;
    /** Cognito ID token */
    idToken?: string;
    /** Token expiration timestamp (epoch seconds) */
    expiresAt?: number;
    /** Error flag for refresh failures */
    error?: string;
  }
}
```

3. Update `src/middleware.ts` (minimal change - withAuth still works):
```typescript
import { withAuth } from "next-auth/middleware";

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      // Allow access if token exists and doesn't have refresh error
      return !!token && token.error !== "RefreshTokenError";
    },
  },
  pages: {
    signIn: "/login",
  },
});

export const config = {
  matcher: [
    "/((?!api|_next/static|_next/image|favicon.ico|login|signup).*)",
  ],
};
```

IMPORTANT: The Cognito 'sub' claim is now the user ID. This is the stable identifier that will be used as DynamoDB partition key in Phase 5.
  </action>
  <verify>
- `src/auth.ts` uses CognitoProvider: `grep "CognitoProvider" src/auth.ts`
- Types include accessToken: `grep "accessToken" src/types/next-auth.d.ts`
- JWT callback handles refresh: `grep "refreshAccessToken" src/auth.ts`
- Middleware checks token error: `grep "RefreshTokenError" src/middleware.ts`
  </verify>
  <done>
Auth.js fully configured with Cognito provider. JWT tokens are automatically refreshed. Cognito 'sub' claim available as user ID for DynamoDB partition key. Middleware protects routes.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Auth config uses Cognito: `grep -c "CognitoProvider" src/auth.ts` returns 1
3. JWT refresh implemented: `grep "refreshAccessToken" src/auth.ts`
4. Types extended for Cognito fields: `grep "expiresAt" src/types/next-auth.d.ts`
5. Dependencies installed: `npm ls aws-jwt-verify`
</verification>

<success_criteria>
- Auth.js configured with CognitoProvider (not CredentialsProvider)
- JWT callbacks store and refresh Cognito tokens
- 60-second buffer prevents token expiration race conditions
- User ID is Cognito 'sub' claim (stable for DynamoDB)
- Session exposes accessToken and error state
- Middleware validates token and handles refresh errors
- Covers requirements: AUTH-03 (Cognito integration), AUTH-05 (JWT sessions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-migration/04-03-SUMMARY.md`
</output>
