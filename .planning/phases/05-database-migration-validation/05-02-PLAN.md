---
phase: 05-database-migration-validation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified: [src/lib/actions/session.ts, src/lib/actions/campaign.ts, src/lib/db/dual-write.ts]
autonomous: true
---

<objective>
Implement dual-write logic in Campaign and Session actions to ensure all new data is written to both PostgreSQL and DynamoDB.

Purpose: Maintain data parity for new records during the 2-week validation period.
Output: Updated server actions that perform atomic-ish dual writes.
</objective>

<execution_context>
@./.gemini/get-shit-done/workflows/execute-plan.md
@./.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-database-migration-validation/05-01-SUMMARY.md
@src/lib/actions/session.ts
@src/lib/actions/campaign.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dual-Write Wrapper Utility</name>
  <files>src/lib/db/dual-write.ts</files>
  <action>
    Create a wrapper or utility to handle dual-write errors.
    If DynamoDB fails but Postgres succeeds, log the error but do not fail the request (primary write is still Postgres for now).
    This ensures application availability while we monitor migration stability.
  </action>
  <verify>Manual check of logs when DynamoDB write is intentionally failed.</verify>
  <done>Utility handles secondary write failures gracefully with logging.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Dual-Write for Campaigns</name>
  <files>src/lib/actions/campaign.ts</files>
  <action>
    Update `createCampaign` and `updateCampaign` actions.
    After the Prisma write, call the ElectroDB entity to `.put()` or `.update()` the same data in DynamoDB.
    Map Postgres UUIDs to the appropriate DynamoDB attributes.
  </action>
  <verify>Create a campaign in the UI (or via script) and verify it exists in both PostgreSQL and DynamoDB.</verify>
  <done>Campaign creation/updates synced to DynamoDB.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Dual-Write for Sessions</name>
  <files>src/lib/actions/session.ts</files>
  <action>
    Update `createSession`, `updateSession`, and transcript-related actions.
    When a transcript is saved:
    1. Upload to S3 via `uploadTranscript`.
    2. Save the S3 key in the DynamoDB `Session` item.
    3. Ensure Postgres still gets the full transcript (for now).
  </action>
  <verify>Create a session with a transcript and verify Postgres has the text while DynamoDB has the S3 pointer.</verify>
  <done>Session data and transcript pointers synced to DynamoDB/S3.</done>
</task>

</tasks>

<verification>
Perform CRUD operations on Campaigns and Sessions and verify DynamoDB contains matching records for every Postgres record created during the test.
</verification>

<success_criteria>
1. New Campaigns appear in DynamoDB.
2. New Sessions appear in DynamoDB.
3. Transcripts for new sessions are uploaded to S3.
4. Failures in DynamoDB writes do not break the main Postgres-driven user flow.
</success_criteria>

<output>
After completion, create `.planning/phases/05-database-migration-validation/05-02-SUMMARY.md`
</output>
